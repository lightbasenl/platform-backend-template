import {
  authTokenPairType,
  emailType,
  passwordType,
  successResponse,
} from "../../structure.js";

/**
 * Extend the app with the auth password based login capabilities.
 *
 * @see extendWithBackendBase
 *
 * @param {import("@compas/code-gen").App} app
 * @returns {Promise<void>}
 */
export async function extendWithAuthPasswordBased(app) {
  const { TypeCreator } = await import("@compas/code-gen");
  const T = new TypeCreator("authPasswordBased");
  const R = T.router("/auth/password-based");

  const email = emailType(T);
  const password = passwordType(T);

  // We also want to support old tokens generated by just using a uuid
  const tokenLength = 36;

  app.add(
    T.object("passwordUpdatedEventMetadata").keys({
      tenant: {
        id: T.uuid(),
        publicUrl: T.string(),
        apiUrl: T.string(),
      },
    }),
    T.object("passwordUpdatedEventData").keys({
      passwordLoginId: T.uuid(),
      metadata: T.reference(
        "authPasswordBased",
        "passwordUpdatedEventMetadata",
      ),
    }),

    T.object("emailUpdatedEventMetadata").keys({
      tenant: {
        id: T.uuid(),
        publicUrl: T.string(),
        apiUrl: T.string(),
      },
    }),
    T.object("emailUpdatedEventData").keys({
      previousEmail: emailType(T),
      passwordLoginId: T.uuid(),
      passwordLoginResetId: T.uuid(),
      metadata: T.reference("authPasswordBased", "emailUpdatedEventMetadata"),
    }),

    T.object("loginVerifiedEventMetadata").keys({
      tenant: {
        id: T.uuid(),
        publicUrl: T.string(),
        apiUrl: T.string(),
      },
    }),
    T.object("loginVerifiedEventData").keys({
      passwordLoginId: T.uuid(),
      metadata: T.reference("authPasswordBased", "loginVerifiedEventMetadata"),
    }),

    T.object("passwordResetEventMetadata").keys({
      tenant: {
        id: T.uuid(),
        publicUrl: T.string(),
        apiUrl: T.string(),
      },
    }),
    T.object("passwordResetEventData").keys({
      passwordLoginId: T.uuid(),
      metadata: T.reference("authPasswordBased", "passwordResetEventMetadata"),
    }),

    T.object("forgotPasswordEventMetadata").keys({
      tenant: {
        id: T.uuid(),
        publicUrl: T.string(),
        apiUrl: T.string(),
      },
    }),
    T.object("forgotPasswordEventData").keys({
      passwordLoginId: T.uuid(),
      passwordLoginResetId: T.uuid(),
      metadata: T.reference("authPasswordBased", "forgotPasswordEventMetadata"),
    }),

    T.object("userRegisteredEventMetadata").keys({}),
    T.object("userRegisteredEventData").keys({
      passwordLoginId: T.uuid(),
      passwordLoginResetId: T.uuid(),
      metadata: T.reference("authPasswordBased", "userRegisteredEventMetadata"),
    }),

    T.object("requestOtpEventMetadata").keys({
      tenant: {
        id: T.uuid(),
        publicUrl: T.string(),
        apiUrl: T.string(),
      },
    }),
    T.object("requestOtpEventData").keys({
      userId: T.uuid(),
      passwordLoginId: T.uuid(),
      otp: T.string(),
      metadata: T.reference("authPasswordBased", "requestOtpEventMetadata"),
    }),

    R.post("/verify-otp", "verifyOtp")
      .docs(
        `Call this when \`ctx.session.type === "checkTwoStep"\` and \`ctx.session.twoStepType === "passwordBasedOtp"\`. Advances the session to
\`type: user\` on successful verification.`,
      )
      .body({
        otp: T.string()
          .min(6)
          .max(6)
          .pattern(/^\d{6}$/gi),
      })
      .response(successResponse),

    R.post("/verify-email", "verifyEmail")
      .docs(
        `
        Verify an email based on the provided 'verifyToken'. The token is not removed
        until expired (after 24 hours). Does not throw on multiple calls with the same
        token. The first verification also updates the \`verifiedAt\` property on the
        \`passwordLogin\` entity. This route returns a token pair for a new session, which can be used to directly log the user in.

        Errors:
        - \`authPasswordBased.verifyEmail.invalidVerifyToken\` -> unknown token or token
            expired. Redirect user to do a 'forgotPassword' flow.
        - \`authPasswordBased.verifyEmail.useResetPassword\` -> token is for
            \`resetPassword\` instead of \`verifyEmail\` (unused after __FEATURE_LPC_AUTH_REDUCE_ERROR_KEY_INFO)
        `,
      )
      .body({
        verifyToken: T.string().min(tokenLength),
        device: T.reference("session", "loginDevice").optional(),
      })
      .response(authTokenPairType(T)),

    R.post("/forgot-password", "forgotPassword")
      .docs(
        `Generate a reset token for the provided email. Can be called many times. The
tokens expire in 24 hours.

Errors:
- \`authPasswordBased.forgotPassword.unknownEmail\` -> email is unknown in the
  platform (unused after __FEATURE_LPC_AUTH_REDUCE_ERROR_KEY_INFO)`,
      )
      .body({
        email,
      })
      .response(successResponse),

    R.post("/reset-password", "resetPassword")
      .docs(
        `Set a new password based on the \`resetToken\` created via
\`apiAuthPasswordForgotPassword\`. Tokens are removed on usage so this route can't
be called multiple times.

Errors:
- \`authPasswordBased.resetPassword.invalidResetToken\` -> unknown token or
  expired. Let the user request a new token via \`forgotPassword\`
- \`authPasswordBased.resetPassword.useVerifyEmail\` -> token is a verify token,
  use \`verifyEmail\` (unused after __FEATURE_LPC_AUTH_REDUCE_ERROR_KEY_INFO)`,
      )
      .body({
        resetToken: T.string().min(tokenLength),
        password,
      })
      .response(successResponse),

    R.post("/login", "login")
      .docs(
        `Do a password based login, requires a verified email.

Errors:
- \`authPasswordBased.login.unknownEmail\` -> can't find a user with the provider
  email (unused after __FEATURE_LPC_AUTH_REDUCE_ERROR_KEY_INFO)
- \`authPasswordBased.login.maxAttemptsExceeded\` -> more then 10 login attempts done in a rolling 5 minute interval
- \`authPasswordBased.login.invalidEmailPasswordCombination\` -> combination of
  email and password is invalid
- \`authPasswordBased.login.emailNotVerified\` -> the password login is not
  verified `,
      )
      .body({
        email,
        password,
        device: T.reference("session", "loginDevice").optional(),
      })
      .response(authTokenPairType(T)),

    R.get("/", "listEmails").response({
      emails: [
        {
          email,
          isVerified: T.bool(),
          verifiedAt: T.date().optional(),
          createdAt: T.date(),
        },
      ],
    }),

    R.post("/update-password", "updatePassword")
      .docs(
        `Set a new password for the logged-in user. Destroys all active sessions
afterwards.

Errors:
- \`authPasswordBased.updateEmail.userWithoutPasswordLogin\` -> user doesn't have
  a password based login, so can't use this functionality`,
      )
      .body({
        password,
      })
      .response(successResponse),

    R.post("/update-email", "updateEmail")
      .docs(
        `Let a logged-in user change its email to a different one. Destroys all active
sessions afterwards. The user email should be verified again.

Errors:
- \`authPasswordBased.updateEmail.userWithoutPasswordLogin\` -> user doesn't have
  a password based login, so can't use this functionality
- \`authPasswordBased.updateEmail.emailAlreadyUsed\` -> email is already in use by
  another user`,
      )
      .body({
        email,
      })
      .response(successResponse),
  );
}
